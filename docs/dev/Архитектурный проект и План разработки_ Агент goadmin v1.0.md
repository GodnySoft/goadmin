# **Архитектурный проект и План разработки: Агент goadmin**

**Проект:** ОСНОВА ИТ (Internal Infrastructure)

**Роль составителя:** Principal Linux & Go Systems Architect (GOADMIN)

**Статус:** Утверждено к разработке

**Целевая платформа:** Ubuntu 24.04 LTS

**Язык:** Golang (1.22+)

---

## **1\. Концепция и Архитектурное видение**

Данный документ является руководством к действию для разработки единого модульного Go-приложения (goadmin). Агент инкапсулирует задачи DevOps/Sysadmin, выступая локальным демоном и CLI-утилитой.

**Главный принцип:** Если систему нельзя воспроизвести — её нет.

Мы строим надежный фундамент, а не набор разрозненных bash-скриптов. Приложение проектируется по паттерну **Ports & Adapters (Модульный монолит)**, что обеспечивает строгую изоляцию бизнес-логики от внешних интерфейсов (CLI, API, Telegram) и системных вызовов ОС.

---

## **2\. Технологический стек**

* **Язык:** Go 1.22+ (использование нового роутера net/http, структурного логирования log/slog).  
* **CLI интерфейс:** github.com/spf13/cobra.  
* **Взаимодействие с ОС:** github.com/shirou/gopsutil/v3, стандартные пакеты os/exec (с безопасными обертками).  
* **Хранилище метрик/логов:** Встроенная SQLite (github.com/mattn/go-sqlite3 или pure-go аналоги).  
* **Web/UI:** Встроенный SPA (React/Vue), отдаваемый через go:embed.  
* **ОС:** Ubuntu 24.04 LTS (systemd, journald).

---

## **3\. Архитектура и Структура репозитория**

Придерживаемся Go Standard Layout. Код должен быть организован так, чтобы добавление нового транспорта или модуля не затрагивало ядро.

Plaintext

goadmin/  
├── cmd/  
│   └── goadmin/  
│       └── main.go       \# Инициализация логгера, конфига, ядра и запуск транспортов  
├── internal/  
│   ├── core/             \# Диспетчер модулей, интерфейс CommandProvider  
│   ├── modules/          \# Реализация бизнес-логики (host, network, docker)  
│   └── transports/       \# Слой входов (cli, web, telegram, maxbot)  
├── pkg/  
│   ├── logger/           \# Обертка над log/slog (вывод в консоль \+ JSON для journald)  
│   └── shell/            \# Пакет для безопасного вызова os/exec с context.Context  
├── configs/              \# Шаблоны конфигурации (config.example.yaml)  
└── deployments/          \# systemd юниты и Ansible плейбуки

### **3.1. Интерфейсный контракт (Core)**

Каждый модуль должен удовлетворять единому контракту. Пример (для разработчика):

Go

// CommandProvider определяет контракт для любого исполняемого модуля системы.  
type CommandProvider interface {  
    // Name возвращает уникальное имя модуля (например, "host", "docker").  
    Name() string  
    // Init инициализирует модуль при старте демона.  
    Init(ctx context.Context, cfg \*Config) error  
    // Execute выполняет команду, переданную через транспорт.  
    Execute(ctx context.Context, cmd string, args \[\]string) (Response, error)  
}

---

## **4\. Кодовые стандарты (Strict Rules)**

Разработчик обязан соблюдать следующие правила:

1. **Обработка ошибок:** Никакого игнорирования (\_). Каждая ошибка должна быть либо обработана, либо обернута (fmt.Errorf("module host failed: %w", err)) и проброшена наверх.  
2. **Concurrency:** Использование горутин **только** с context.Context. Никаких утечек (goroutine leaks). Обязательная реализация Graceful Shutdown для всех фоновых процессов.  
3. **Комментирование:** Комментарии в коде пишутся на русском языке. Описывается *почему* принято решение, а не *что* делает код (это должно быть понятно из нейминга).  
4. **Безопасность (Zero-Trust):** Ни один внешний транспорт не имеет прямого доступа к os/exec. Все идет через строгую валидацию в internal/core.

---

## **5\. Поэтапный план реализации (Roadmap)**

### **Этап 1: Фундамент и CLI (MVP)**

* Инициализовать репозиторий, настроить golangci-lint и GitHub Actions / GitLab CI.  
* Написать слой internal/core с регистратором плагинов.  
* Реализовать пакет pkg/logger на базе log/slog.  
* Реализовать модуль internal/modules/host (сбор метрик CPU/RAM, чтение os-release и uptime через gopsutil).  
* Подключить Cobra в internal/transports/cli.  
* **Результат:** Готовый бинарник, который локально выполняет goadmin host status.

### **Этап 2: Режим Демона и База Данных**

* Добавить команду goadmin serve для запуска в фоновом режиме.  
* Реализовать перехват системных сигналов (SIGINT, SIGTERM) для Graceful Shutdown.  
* Внедрить SQLite: создать миграции таблиц для сохранения истории метрик.  
* Написать внутренний планировщик (Cron/Ticker) в core для периодического опроса модулей и записи результатов в БД.  
* **Результат:** Агент работает в фоне, не течет по памяти (проверить через pprof), накапливает статистику.

### **Этап 3: Интеграция Transports (Мессенджеры)**

* Реализовать transports/telegram с использованием long-polling.  
* Реализовать transports/maxbot (API корпоративного мессенджера).  
* Внедрить модуль авторизации в транспорты: проверять ID пользователя по белому списку из config.yaml.  
* Настроить маршрутизацию: текстовая команда /host транслируется в вызов Execute модуля host.  
* **Результат:** Безопасное удаленное выполнение команд через чат с авторизованных аккаунтов.

### **Этап 4: Web-интерфейс (Fleet Management)**

* Написать REST API в transports/web с использованием стандартного net/http (Go 1.22 routing).  
* Подготовить базовый фронтенд (SPA) и упаковать его в бинарник через go:embed.  
* **Результат:** Доступ к дашборду агента через браузер по локальному IP/порту.

### **Этап 5: Инфраструктура и Hardening**

* Создать deployments/systemd/goadmin.service с применением изоляции (Hardening): ProtectSystem=strict, NoNewPrivileges=true, PrivateTmp=true.  
* Написать Ansible-роль deployments/ansible/ для автоматизированного скачивания бинарника в /usr/local/bin/goadmin, создания системного пользователя goadmin, генерации конфига и запуска службы.  
* **Результат:** Полностью автоматизированное, безопасное развертывание на Ubuntu 24.04 LTS.

---

## **6\. Метрики успеха (KPI для разработчика)**

* **Код компилируется** статически без внешних CGO-зависимостей (за исключением SQLite драйвера, если не используется pure-go порт).  
* **Покрытие тестами** модулей ядра и парсеров не менее 70%.  
* **Отсутствие race conditions** (обязательная проверка сборкой с ключом \-race).  
* **Безопасность:** прохождение сканера gosec в CI без критических предупреждений.

---

Документ обновлен и структурирован.

Хочешь ли ты, чтобы я подготовил стартовый main.go и базовую инициализацию Cobra (Boilerplate) для проекта goadmin, чтобы разработчик мог сразу скопировать правильную структуру запуска с учетом Graceful Shutdown?

